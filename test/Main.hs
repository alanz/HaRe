{-# LANGUAGE CPP #-}
{-# LANGUAGE OverloadedStrings #-}

module Main where

import Control.Monad
-- import TestUtils
import qualified Turtle as Tu
import qualified Control.Foldl as Fold
import System.Directory
import System.Process (readProcess)

import Test.Hspec.Runner
import qualified Spec

-- ---------------------------------------------------------------------

data TestEnv = CabalOldBuild
             | CabalNewBuild
             | StackBuild
             deriving (Eq,Show,Ord)

-- ---------------------------------------------------------------------

main :: IO ()
main = do
  -- setLogger
  let testBuild = CabalNewBuild
  -- let testBuild = StackBuild
  cleanupDirs (Tu.ends     "/stack.yaml")
  cleanupDirs (Tu.ends     "/hie.yaml")
  cleanupDirs (Tu.ends     "/.stack-work")
  cleanupDirs (Tu.ends     "/dist")
  cleanupDirs (Tu.ends     "/dist-newstyle")
  cleanupDirs (Tu.contains ".ghc.environ")
  case testBuild of
    CabalOldBuild -> setupDistDirs testBuild
    CabalNewBuild -> setupDistDirs testBuild
    StackBuild    -> setupStackFiles
  hspec Spec.spec

-- ---------------------------------------------------------------------

setupStackFiles :: IO ()
setupStackFiles =
  forM_ cabalDirs $ \f -> do
    writeFile (f ++ "stack.yaml") stackFileContents
    writeFile (f ++ "hie.yaml") hieYamlCradleStackContents

setupDistDirs :: TestEnv -> IO ()
setupDistDirs testEnv =
  forM_ cabalDirs $ \d -> do
    withCurrentDirectory d $ do
      writeFile "hie.yaml" hieYamlCradleCabalContents
      case testEnv of
        CabalOldBuild -> do
          run "cabal" [ "install", "--dependencies-only" ]
          run "cabal" [ "configure" ]
        CabalNewBuild -> do
          -- run "cabal" [ "new-configure" ]
          -- run "cabal" [ "new-build" ]
          return ()
        StackBuild -> error "Main.setupDistDirs: got StackBuild"

-- This is shamelessly copied from cabal-helper GhcSession test.
run :: String -> [String] -> IO ()
run x xs = do
  print $ x:xs
  o <- readProcess x xs ""
  putStrLn o
  return ()

-- ---------------------------------------------------------------------

cabalDirs :: [FilePath]
cabalDirs =
  [  "./test/testdata/"
   , "./test/testdata/cabal/cabal1/"
   , "./test/testdata/cabal/cabal2/"
   , "./test/testdata/cabal/cabal3/"
   , "./test/testdata/cabal/cabal4/"
   , "./test/testdata/cabal/foo/"
  ]

stackFiles :: [FilePath]
stackFiles = map (++"stack.yaml") cabalDirs

-- |Choose a resolver based on the current compiler, otherwise HaRe/ghc-mod will
-- not be able to load the files
resolver :: String
resolver =
#if (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,6,5,0)))
  "resolver: lts-13.21"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,6,4,0)))
  "resolver: lts-13.16"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,6,3,0)))
  "resolver: lts-13.9"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,6,1,0)))
  "resolver: nightly-2018-11-07"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,4,0)))
  "resolver: lts-12.17"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,3,0)))
  "resolver: nightly-2018-06-29"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,2,0)))
  "resolver: nightly-2018-04-24"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,1,0)))
  "resolver: nightly-2018-04-21" -- last one for GHC 8.4.1
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,2,2,0)))
  "resolver: lts-11.6"
#elif __GLASGOW_HASKELL__ >= 802
  "resolver: nightly-2017-09-02"
#elif __GLASGOW_HASKELL__ > 710
  "resolver: nightly-2017-05-23"
#else
  "resolver: lts-6.13"
#endif

-- ---------------------------------------------------------------------

stackFileContents :: String
stackFileContents = unlines
  [ "# WARNING: THIS FILE IS AUTOGENERATED IN test/Main.hs. IT WILL BE OVERWRITTEN ON EVERY TEST RUN"
  , resolver
  , "packages:"
  , "- '.'"
  , "extra-deps: "
  -- , "- conversion-1.2.1"
  -- , "- conversion-bytestring-1.0.1"
  -- , "- conversion-case-insensitive-1.0.0.0"
  -- , "- conversion-text-1.0.1"
  -- , "- syb-0.7"
#if (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,2,0)))
    , "- conversion-1.2.1"
    , "- conversion-case-insensitive-1.0.0.0"
    , "- conversion-text-1.0.1"
    , "- conversion-bytestring-1.0.1"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,4,1,0)))
  -- , "- Cabal-2.2.0.0"
  -- , "- attoparsec-0.13.2.2"
  -- , "- base-prelude-1.2.0.1"
  -- , "- case-insensitive-1.2.0.10"
  -- , "- hashable-1.2.7.0"
  -- , "- scientific-0.3.5.2"
  -- , "- integer-logarithms-1.0.2.1"
  -- , "- primitive-0.6.3.0"
#elif (defined(MIN_VERSION_GLASGOW_HASKELL) && (MIN_VERSION_GLASGOW_HASKELL(8,2,2,0)))
    , "- conversion-1.2.1"
    , "- conversion-bytestring-1.0.1"
    , "- conversion-case-insensitive-1.0.0.0"
    , "- conversion-text-1.0.1"
    , "- syb-0.7"
#elif __GLASGOW_HASKELL__ >= 802
    , "- conversion-1.2.1"
    , "- conversion-bytestring-1.0.1"
    , "- conversion-case-insensitive-1.0.0.0"
    , "- conversion-text-1.0.1"
    , "- syb-0.7"
#elif __GLASGOW_HASKELL__ > 710
#endif
  ]

-- ---------------------------------------------------------------------

hieYamlCradleStackContents :: String
hieYamlCradleStackContents = unlines
  [ "# WARNING: THIS FILE IS AUTOGENERATED IN test/Main.hs. IT WILL BE OVERWRITTEN ON EVERY TEST RUN"
  , "cradle:"
  , "  stack:"
  ]

hieYamlCradleCabalContents :: String
hieYamlCradleCabalContents = unlines
  (
  [ "# WARNING: THIS FILE IS AUTOGENERATED IN test/Main.hs. IT WILL BE OVERWRITTEN ON EVERY TEST RUN"
  , "cradle:"
  -- , "  cabal:"
  -- , "  cabal: \"testdata:a1\""
  -- , "    { cabal: {component: \"testdata:a1\"} }"
  -- , "    { cabal: {component: \"cabal1\"} }"

  , "  multi:"
  ]

  -- testdata root
  ++ makeCabalCradleTarget "./B.hs"      "lib:testdata"
  ++ makeCabalCradleTarget "./BCpp.hs"   "lib:testdata"
  ++ makeCabalCradleTarget "./BCppTC.hs" "lib:testdata"
  ++ makeCabalCradleTarget "./AddOneParameter/PatIn1.hs"    "lib:testdata"
  ++ makeCabalCradleTarget "./AddOneParameter/FunIn1.hs"    "lib:testdata"
  ++ makeCabalCradleTarget "./AddOneParameter/FunIn2.hs"    "lib:testdata"
  ++ makeCabalCradleTarget "./AddOneParameter/FunIn3.hs"    "lib:testdata"
  ++ makeCabalCradleTarget "./AddOneParameter/FunIn4.hs"    "lib:testdata"
  ++ makeCabalCradleTarget "./AddOneParameter/FunIn6.hs"    "lib:testdata"
  ++ makeCabalCradleTarget "./AddOneParameter/Nested.hs"    "lib:testdata"
  ++ makeCabalCradleTarget "./AddOneParameter/MultiFun1.hs" "lib:testdata"

  ++ makeCabalCradleTarget "./AddOneParameter/A1.hs" "addoneparama1"
  ++ makeCabalCradleTarget "./AddOneParameter/C1.hs" "addoneparama1"
  ++ makeCabalCradleTarget "./AddOneParameter/D1.hs" "addoneparama1"

  ++ makeCabalCradleTarget "./AddOneParameter/A2.hs" "addoneparama2"
  ++ makeCabalCradleTarget "./AddOneParameter/C2.hs" "addoneparama2"
  ++ makeCabalCradleTarget "./AddOneParameter/D2.hs" "addoneparama2"

  ++ makeCabalCradleTarget "./AddOneParameter/A3.hs" "addoneparama3"
  ++ makeCabalCradleTarget "./AddOneParameter/D3.hs" "addoneparama3"

  -- cabal/cabal1 [need to make specific for the dir]
  ++ makeCabalCradleTarget "./src/main.hs" "cabal1"
  ++ makeCabalCradleTarget "./src/Foo/Bar.hs" "cabal1"
  ++ makeCabalCradleTarget "./src/main.hs" "cabal1"

  -- cabal/cabal4 [need to make specific for the dir]
  ++ makeCabalCradleTarget "./src/Foo/Bar.hs" "cabal4"

  )

{-
cradle:
  multi:
    - path: "./src"
      config: { cradle: {cabal: {component: "lib:hie-bios"}} }
    - path: "./test"
      config: { cradle: {cabal: {component: "test"}} }
    - path: "./test/test-files"
      config: { cradle: none }
-}

makeCabalCradleTarget :: FilePath -> String -> [String]
makeCabalCradleTarget subdir component =
  [ "    - path: \"" ++ subdir ++ "\""
  , "      config: { cradle: {cabal: {component: \"" ++ component ++ "\"}} }"
  ]

-- ---------------------------------------------------------------------

cleanupDirs :: Tu.Pattern t -> IO ()
cleanupDirs ending = do
  dirs <- getDirs ending
  forM_ dirs  $ \dir -> Tu.rmtree dir

getDirs :: Tu.Pattern t -> IO [Tu.FilePath]
getDirs ending = do
  let
    -- dirs = Tu.find (Tu.ends "/.stack-work") "./test"
    dirs = Tu.find ending "./test"
  Tu.fold dirs Fold.list

listStackDirs :: IO ()
listStackDirs = Tu.sh $ do
  dirs <- Tu.find (Tu.ends "/.stack-work") "./test"
  mapM Tu.echo $ Tu.textToLines $ "found:" Tu.<> (Tu.repr dirs)
